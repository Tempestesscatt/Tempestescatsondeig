# -*- coding: utf-8 -*-
import streamlit as st
import openmeteo_requests
from retry_requests import retry
import requests
import numpy as np
import pandas as pd
import random
import time
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import matplotlib.lines as mlines
import matplotlib.patches as patches
from metpy.plots import SkewT, Hodograph
from metpy.units import units
import metpy.calc as mpcalc
from matplotlib.patches import Circle, Polygon
import cartopy.crs as ccrs
import cartopy.feature as cfeature
from scipy.interpolate import griddata, Rbf
from datetime import datetime, timedelta
import pytz
import matplotlib.patheffects as path_effects

# --- CONFIGURACI√ìN INICIAL ---
st.set_page_config(layout="wide", page_title="Tempestes.cat")
plain_session = requests.Session()
retry_session = retry(plain_session, retries=5, backoff_factor=0.2)
openmeteo = openmeteo_requests.Client(session=retry_session)
FORECAST_DAYS = 1
CONVERGENCIA_FORTA_THRESHOLD = -15

# --- DATOS DE LOCALIDADES ---
pobles_data = {
    'Bag√†': {'lat': 42.254, 'lon': 1.860}, 'Berga': {'lat': 42.105, 'lon': 1.846},
    'Solsona': {'lat': 41.994, 'lon': 1.518}, 'Ripoll': {'lat': 42.201, 'lon': 2.190},
    'Vic': {'lat': 41.930, 'lon': 2.255}, 'Olot': {'lat': 42.181, 'lon': 2.490},
    'Manresa': {'lat': 41.727, 'lon': 1.825}, 'Lleida': {'lat': 41.617, 'lon': 0.620},
    'T√†rrega': {'lat': 41.647, 'lon': 1.140}, 'Albi': {'lat': 41.423, 'lon': 0.995},
    'Montblanc': {'lat': 41.376, 'lon': 1.161}, 'Gandesa': {'lat': 41.052, 'lon': 0.437},
    'Figueres': {'lat': 42.266, 'lon': 2.963}, 'Arb√∫cies': {'lat': 41.815, 'lon': 2.515},
    'Arenys de Mar': {'lat': 41.581, 'lon': 2.551},
}

# --- FUNCI√ìN DE CALLBACK ---
def actualitzar_seleccio(poble, hora):
    st.session_state.poble_selector = poble
    st.session_state.hora_selector = f"{hora:02d}:00h"
    st.session_state.avisos_expanded = False

# --- INICIALIZACI√ìN DEL SESSION STATE ---
if 'poble_selector' not in st.session_state or st.session_state.poble_selector not in pobles_data:
    st.session_state.poble_selector = 'Vic'
if 'hora_selector' not in st.session_state:
    tz = pytz.timezone('Europe/Madrid')
    st.session_state.hora_selector = f"{datetime.now(tz).hour:02d}:00h"
if 'nivell_mapa' not in st.session_state:
    st.session_state.nivell_mapa = 850
if 'avisos_expanded' not in st.session_state:
    st.session_state.avisos_expanded = True

# --- 1. L√ìGICA DE CARGA DE DATOS Y C√ÅLCULO ---
@st.cache_data(ttl=16000)
def carregar_sondeig_per_poble(nom_poble, lat, lon):
    p_levels = [1000, 925, 850, 700, 600, 500, 400, 300, 250, 200, 150, 100]
    h_base = ["temperature_2m", "dew_point_2m", "surface_pressure"]
    h_press = [f"{v}_{p}hPa" for v in ["temperature", "dew_point", "wind_speed", "wind_direction", "geopotential_height"] for p in p_levels]
    params = {"latitude": lat, "longitude": lon, "hourly": h_base + h_press, "models": "arome_seamless", "timezone": "auto", "forecast_days": FORECAST_DAYS}
    try:
        respostes = openmeteo.weather_api("https://api.open-meteo.com/v1/forecast", params=params)
        return respostes[0], p_levels, None
    except Exception as e: return None, None, str(e)

@st.cache_data(ttl=16000)
def obtener_dades_mapa(variable, nivell, hourly_index, forecast_days):
    lats, lons = np.linspace(40.5, 42.8, 12), np.linspace(0.2, 3.3, 12)
    lon_grid, lat_grid = np.meshgrid(lons, lats); api_vars = []
    if variable == 'temp_height': api_vars = [f"temperature_{nivell}hPa", f"geopotential_height_{nivell}hPa"]
    elif variable == 'wind': api_vars = [f"wind_speed_{nivell}hPa", f"wind_direction_{nivell}hPa"]
    elif variable == 'dewpoint': api_vars = [f"dew_point_{nivell}hPa"]
    elif variable == 'humidity': api_vars = [f"relative_humidity_{nivell}hPa"]
    elif variable == 'cape': api_vars = ["cape"]
    else: api_vars = [f"temperature_{nivell}hPa"]
    params = {"latitude": lat_grid.flatten().tolist(), "longitude": lon_grid.flatten().tolist(), "hourly": api_vars, "models": "arome_seamless", "timezone": "auto", "forecast_days": forecast_days}
    try:
        responses = openmeteo.weather_api("https://api.open-meteo.com/v1/forecast", params=params)
        lats_out, lons_out, data_out = [], [], []
        for r in responses:
            hourly = r.Hourly(); values = [hourly.Variables(i).ValuesAsNumpy()[hourly_index] for i in range(len(api_vars))]
            if not any(np.isnan(v) for v in values):
                lats_out.append(r.Latitude()); lons_out.append(r.Longitude()); data_out.append(tuple(values) if len(values) > 1 else values[0])
        if not lats_out: return None, None, None, "No s'han rebut dades v√†lides del model."
        return lats_out, lons_out, data_out, None
    except Exception as e: return None, None, None, str(e)

@st.cache_data(ttl=16000)
def calcular_convergencia_per_totes_les_localitats(_hourly_index, _nivell, _localitats_dict):
    lats_mapa, lons_mapa, data_mapa, error = obtener_dades_mapa('wind', _nivell, _hourly_index, FORECAST_DAYS)
    if error or not lats_mapa or len(lats_mapa) < 4: return {}
    speeds, dirs = zip(*data_mapa); speeds_ms = (np.array(speeds) * 1000 / 3600) * units('m/s'); dirs_deg = np.array(dirs) * units.degrees
    u_comp, v_comp = mpcalc.wind_components(speeds_ms, dirs_deg)
    grid_lon, grid_lat = np.linspace(min(lons_mapa), max(lons_mapa), 50), np.linspace(min(lats_mapa), max(lats_mapa), 50)
    X, Y = np.meshgrid(grid_lon, grid_lat); points = np.vstack((lons_mapa, lats_mapa)).T
    u_grid = griddata(points, u_comp.m, (X, Y), method='cubic'); v_grid = griddata(points, v_comp.m, (X, Y), method='cubic')
    u_grid, v_grid = np.nan_to_num(u_grid), np.nan_to_num(v_grid); dx, dy = mpcalc.lat_lon_grid_deltas(X, Y)
    divergence_grid = mpcalc.divergence(u_grid * units('m/s'), v_grid * units('m/s'), dx=dx, dy=dy) * 1e5
    convergencia_per_poble = {}
    for nom_poble, coords in _localitats_dict.items():
        try:
            lon_idx, lat_idx = (np.abs(grid_lon - coords['lon'])).argmin(), (np.abs(grid_lat - coords['lat'])).argmin()
            convergencia_per_poble[nom_poble] = divergence_grid.m[lat_idx, lon_idx]
        except Exception: continue
    return convergencia_per_poble

@st.cache_data(ttl=16000)
def precalcular_potencials_del_dia(_pobles_data):
    horas_muestreadas = [0, 3, 6, 9, 12, 15, 18, 21]; potencials = {}
    avisos_a_buscar = {"PRECAUCI√ì", "AV√çS", "RISC ALT", "ALERTA DE DISPARADOR"}
    for nom_poble, coords in _pobles_data.items():
        try:
            sondeo, p_levels, _ = carregar_sondeig_per_poble(nom_poble, coords['lat'], coords['lon'])
            if sondeo:
                for hora in horas_muestreadas:
                    profiles = processar_sondeig_per_hora(sondeo, hora, p_levels)
                    if profiles:
                        parametros = calculate_parameters(*profiles)
                        if generar_avis_potencial_per_precalcul(parametros) in avisos_a_buscar:
                            potencials[nom_poble] = hora; break
            time.sleep(0.2)
        except Exception: continue
    return potencials

def generar_avis_potencial_per_precalcul(params):
    cape_u = params.get('CAPE_Utilitzable', {}).get('value', 0); cin = params.get('CIN_Fre', {}).get('value')
    if cape_u > 500 and (cin is None or cin > -50): return "ALERTA DE DISPARADOR"
    shear = params.get('Shear_0-6km', {}).get('value'); srh1 = params.get('SRH_0-1km', {}).get('value'); lcl_agl = params.get('LCL_AGL', {}).get('value', 9999)
    if cape_u < 100 or (cin is not None and cin < -100): return "ESTABLE"
    cond_supercelula = shear is not None and shear > 20 and cape_u > 1500 and srh1 is not None and srh1 > 250 and lcl_agl < 1200
    cond_avis_sever = shear is not None and shear > 18 and cape_u > 1000
    cond_precaucio = shear is not None and shear > 12 and cape_u > 500
    if cond_supercelula: return "RISC ALT"
    if cond_avis_sever: return "AV√çS"
    if cond_precaucio: return "PRECAUCI√ì"
    return "RISC BAIX"

def processar_sondeig_per_hora(sondeo, hourly_index, p_levels):
    try:
        hourly = sondeo.Hourly(); T_s, Td_s, P_s = (hourly.Variables(i).ValuesAsNumpy()[hourly_index] for i in range(3))
        if np.isnan(P_s): return None
        s_idx, n_plvls = 3, len(p_levels); T_p, Td_p, Ws_p, Wd_p, H_p = ([hourly.Variables(s_idx + i*n_plvls + j).ValuesAsNumpy()[hourly_index] for j in range(n_plvls)] for i in range(5))
        def interpolate_sfc(sfc_val, p_sfc, p_api, d_api):
            valid_p, valid_d = [p for p, t in zip(p_api, d_api) if not np.isnan(t)], [t for t in d_api if not np.isnan(t)]
            if np.isnan(sfc_val) and len(valid_p) > 1:
                p_sorted, d_sorted = zip(*sorted(zip(valid_p, valid_d))); return np.interp(p_sfc, p_sorted, d_sorted)
            return sfc_val
        T_s, Td_s = interpolate_sfc(T_s, P_s, p_levels, T_p), interpolate_sfc(Td_s, P_s, p_levels, Td_p)
        if np.isnan(T_s) or np.isnan(Td_s): return None
        p_profile, T_profile, Td_profile, u_profile, v_profile, h_profile = [P_s], [T_s], [Td_s], [0.0], [0.0], [mpcalc.pressure_to_height_std(P_s*units.hPa).m]
        for i, p_level in enumerate(p_levels):
            if p_level < P_s and not np.isnan(T_p[i]):
                p_profile.append(p_level); T_profile.append(T_p[i]); Td_profile.append(Td_p[i]); h_profile.append(H_p[i])
                u_comp, v_comp = mpcalc.wind_components(Ws_p[i]*units.knots, Wd_p[i]*units.degrees)
                u_profile.append(u_comp.to('m/s').m); v_profile.append(v_comp.to('m/s').m)
        return (np.array(p_profile)*units.hPa, np.array(T_profile)*units.degC, np.array(Td_profile)*units.degC, np.array(u_profile)*units.m/units.s, np.array(v_profile)*units.m/units.s, np.array(h_profile)*units.m)
    except Exception: return None

def get_next_arome_update_time():
    now_utc = datetime.now(pytz.utc); run_hours_utc = [0, 6, 12, 18]; availability_delay = timedelta(hours=4)
    next_update_time = None
    for run_hour in run_hours_utc:
        available_time = now_utc.replace(hour=run_hour, minute=0, second=0, microsecond=0) + availability_delay
        if available_time > now_utc: next_update_time = available_time; break
    if next_update_time is None: next_update_time = (now_utc + timedelta(days=1)).replace(hour=0, minute=0, second=0, microsecond=0) + availability_delay
    return f"Pr√≤xima actualitzaci√≥ de dades (AROME) estimada a les {next_update_time.astimezone(pytz.timezone('Europe/Madrid')).strftime('%H:%Mh')}"

@st.cache_data(ttl=16000)
def _calculate_parameters_cached(p_m, p_units_str, T_m, T_units_str, Td_m, Td_units_str, u_m, u_units_str, v_m, v_units_str, h_m, h_units_str):
    p = p_m * units(p_units_str); T = T_m * units(T_units_str); Td = Td_m * units(Td_units_str)
    u = u_m * units(u_units_str); v = v_m * units(v_units_str); h = h_m * units(h_units_str)
    params = {}; get_val = lambda qty, unit=None: qty.to(unit).m if unit and hasattr(qty, 'is_compatible_with') and qty.is_compatible_with(unit) else qty.m
    try: params['SFC_Temp'] = {'value': get_val(T[0], 'degC'), 'units': '¬∞C'}
    except Exception: pass
    try:
        prof = mpcalc.parcel_profile(p, T[0], Td[0]); cape, cin = mpcalc.cape_cin(p, T, Td, prof)
        params['CAPE_Brut'] = {'value': get_val(cape, 'J/kg'), 'units': 'J/kg'}; params['CIN_Fre'] = {'value': get_val(cin, 'J/kg'), 'units': 'J/kg'}
        if params.get('CAPE_Brut', {}).get('value', 0) > 0:
            params['W_MAX'] = {'value': np.sqrt(2 * params['CAPE_Brut']['value']), 'units': 'm/s'}
            params['CAPE_Utilitzable'] = {'value': max(0, params['CAPE_Brut']['value'] - abs(params['CIN_Fre']['value'])), 'units': 'J/kg'}
    except Exception: pass
    try: 
        lcl_p, _ = mpcalc.lcl(p[0], T[0], Td[0]); lcl_h = mpcalc.pressure_to_height_std(lcl_p)
        params['LCL_AGL'] = {'value': get_val(lcl_h - h[0], 'm'), 'units': 'm'}
    except Exception: pass
    try: 
        prof = mpcalc.parcel_profile(p, T[0], Td[0]); lfc_p, _ = mpcalc.lfc(p, T, Td, prof=prof)
        lfc_h = mpcalc.pressure_to_height_std(lfc_p); params['LFC_AGL'] = {'value': get_val(lfc_h - h[0], 'm'), 'units': 'm'}
    except Exception: pass
    try: 
        prof = mpcalc.parcel_profile(p, T[0], Td[0]); el_p, _ = mpcalc.el(p, T, Td, prof=prof)
        el_h = mpcalc.pressure_to_height_std(el_p); params['EL_MSL'] = {'value': get_val(el_h, 'km'), 'units': 'km'}
    except Exception: pass
    try: 
        s_u, s_v = mpcalc.bulk_shear(p, u, v, height=h, depth=6*units.km)
        params['Shear_0-6km'] = {'value': get_val(mpcalc.wind_speed(s_u, s_v), 'm/s'), 'units': 'm/s'}
    except Exception: pass
    try: 
        _, srh, _ = mpcalc.storm_relative_helicity(h, u, v, depth=1*units.km)
        params['SRH_0-1km'] = {'value': get_val(srh, 'm^2/s^2'), 'units': 'm¬≤/s¬≤'}
    except Exception: pass
    try: 
        pwat = mpcalc.precipitable_water(p, Td); params['PWAT_Total'] = {'value': get_val(pwat, 'mm'), 'units': 'mm'}
    except Exception: pass
    try:
        T_c, H_m = T.to('degC').m, h.to('m').m
        if idx := np.where(np.diff(np.sign(T_c))[0]).size > 0:
            h_zero_iso_msl = np.interp(0, [T_c[idx[0]+1], T_c[idx[0]]], [H_m[idx[0]+1], H_m[idx[0]]])
            params['ZeroIso_AGL'] = {'value': (h_zero_iso_msl - H_m[0]), 'units': 'm'}
    except Exception: pass
    try:
        p_levels_interp = np.arange(max(100, p.m.min()), p.m.max(), -10) * units.hPa; T_interp = mpcalc.interpolate_1d(p_levels_interp, T, p)
        lr = mpcalc.lapse_rate(p_levels_interp, T_interp, bottom=700*units.hPa, top=500*units.hPa)
        params['LapseRate_700_500'] = {'value': get_val(lr, 'delta_degC/km'), 'units': '¬∞C/km'}
    except Exception: pass
    try: 
        dcape, _ = mpcalc.dcape(p, T, Td); params['DCAPE'] = {'value': get_val(dcape, 'J/kg'), 'units': 'J/kg'}
    except Exception: pass
    try:
        cape_val = params.get('CAPE_Utilitzable',{}).get('value',0) * units('J/kg'); lcl_val = params.get('LCL_AGL',{}).get('value',9999) * units.m
        srh_val = params.get('SRH_0-1km',{}).get('value',0) * units('m^2/s^2'); shear_val = params.get('Shear_0-6km',{}).get('value',0) * units('m/s')
        stp_cin = mpcalc.significant_tornado(cape=cape_val, lcl_height=lcl_val, storm_helicity=srh_val, bulk_shear=shear_val)
        params['STP_cin'] = {'value': get_val(stp_cin, dimensionless=True), 'units': ''}
    except Exception: pass
    return params

def calculate_parameters(p, T, Td, u, v, h):
    return _calculate_parameters_cached(p.m, str(p.units), T.m, str(T.units), Td.m, str(Td.units), u.m, str(u.units), v.m, str(v.units), h.m, str(h.units))

# --- 2. FUNCIONES DE VISUALIZACI√ìN Y FORMATO ---
def display_avis_principal(titol_av√≠s, text_av√≠s, color_av√≠s, icona_personalitzada=None):
    icon_map = {"ESTABLE": "‚òÄÔ∏è", "RISC BAIX": "‚òÅÔ∏è", "PRECAUCI√ì": "‚ö°Ô∏è", "AV√çS": "‚ö†Ô∏è", "RISC ALT": "üå™Ô∏è", "POTENCIAL SEVER": "üßê", "POTENCIAL MODERAT": "ü§î", "ALERTA DE DISPARADOR": "üéØ"}
    icona = icona_personalitzada if icona_personalitzada else icon_map.get(titol_av√≠s, "‚ÑπÔ∏è"); st.markdown(f"""
    <div style="padding: 1rem; border-radius: 0.5rem; background-color: var(--secondary-background-color); border-left: 8px solid {color_av√≠s}; box-shadow: 0 4px 15px rgba(0,0,0,0.1); margin-bottom: 1rem; display: flex; align-items: center; gap: 1rem;">
        <div style="font-size: 3.5em; line-height: 1;">{icona}</div>
        <div><h3 style="color: {color_av√≠s}; margin-top: 0; margin-bottom: 0.5rem; font-weight: bold;">{titol_av√≠s}</h3><p style="margin-bottom: 0; color: var(--text-color);">{text_av√≠s}</p></div>
    </div>""", unsafe_allow_html=True)

def get_parameter_style(param_name, value):
    color = "inherit"; emoji = "";
    if value is None or not isinstance(value, (int, float, np.number)): return color, emoji
    if param_name == 'SFC_Temp':
        if value > 36: color, emoji = "#FF0000", "üî•";
        elif value > 32: color = "#FF4500";
        elif value <= 0: color, emoji = "#0000FF", "ü•∂"
    elif param_name == 'CIN_Fre':
        if value >= -25: color, emoji = "#32CD32", "‚úÖ";
        elif value < -150: color, emoji = "#FF4500", "‚õî"
    elif 'CAPE' in param_name:
        if value > 3500: color, emoji = "#FF00FF", "üí•";
        elif value > 2500: color = "#FF4500";
        elif value > 1500: color = "#FFA500"
    elif 'Shear' in param_name:
        if value > 25: color, emoji = "#FF4500", "‚ÜîÔ∏è";
        elif value > 18: color = "#FFA500"
    elif 'SRH' in param_name:
        if value > 400: color, emoji = "#FF00FF", "üîÑ";
        elif value > 250: color = "#FF4500"
    elif 'DCAPE' in param_name:
        if value > 1200: color, emoji = "#FF4500", "üí®";
        elif value > 800: color = "#FFA500"
    elif 'STP' in param_name:
        if value > 1: color, emoji = "#FF00FF", "üå™Ô∏è";
        elif value > 0.5: color = "#FFA500"
    elif 'LapseRate' in param_name:
        if value > 7.0: color, emoji = "#FF4500", "üßä";
        elif value > 6.5: color = "#FFA500"
    elif 'PWAT' in param_name:
        if value > 40: color, emoji = "#0000FF", "üíß";
        elif value > 30: color = "#4682B4"
    elif 'LCL' in param_name:
        if value < 1000: color, emoji = "#FFA500", "üëá";
    elif 'EL' in param_name:
        if value > 14: color, emoji = "#FF4500", "üîù";
        elif value > 12: color = "#FFA500"
    return color, emoji

def generar_avis_temperatura(params):
    temp = params.get('SFC_Temp', {}).get('value')
    if temp is None: return None, None, None, None
    if temp > 36: return "AV√çS PER CALOR EXTREMA", f"Es preveu una temperatura de {temp:.1f}¬∞C. Risc molt alt.", "#FF0000", "ü•µ"
    if temp < 0: return "AV√çS PER FRED INTENS", f"Es preveu una temperatura de {temp:.1f}¬∞C. Risc de gelades fortes.", "#0000FF", "ü•∂"
    return None, None, None, None

